version: '3'

vars:
  # Output folder names
  BUILD: '{{.BUILD | default ".build"}}'
  LINT_REPORT: '{{.LINT_REPORT | default "lint-report"}}'
  COVER_REPORT: '{{.COVER_REPORT | default "coverage-report"}}'
  TEST_REPORT: '{{.TEST_REPORT | default "test-report"}}'

  COVERAGE: '{{.COVERAGE | default "100%"}}'
  COVER: '{{.COVER | default "."}}'
  PROJECT:
    sh: go list -m
  PACKAGES:
    sh: |
      echo $(go list ./...)

  # Externally passed configuration locations
  CONFIG_DIR: '{{.CONFIG_DIR | default "./config"}}'
  SCRIPTS_DIR: '{{.SCRIPTS_DIR | default "./scripts"}}'

tasks:
  # Utilities
  # ---------
  init:
    run: once
    cmds:
      - mkdir -p {{.BUILD}}
    status:
      - test -d {{.BUILD}}

  clean:
    cmds:
      - rm -rf {{.BUILD}}
      - rm -rf .cache
      - go clean -testcache

  mod:
    cmds:
      - go mod download
      - go mod tidy

  # Build
  # ---------
  build:
    desc: build go project
    cmds:
      - go build {{.CLI_ARGS}} -o {{.BUILD}}/ {{.PACKAGES}}

  release:
    desc: build go project for Linux and Windows with debug information stripped
    cmds:
      - GOOS=windows go build -ldflags='-s -w -X "main.versionStamp={{.SOURCE_BRANCH}}"' {{.CLI_ARGS}} -o {{.BUILD}}/ {{.PACKAGES}}
      - GOOS=linux go build -ldflags='-s -w -X "main.versionStamp={{.SOURCE_BRANCH}}"' {{.CLI_ARGS}} -o {{.BUILD}}/ {{.PACKAGES}}
    vars:
      DEFAULT: '{{.GIT_BRANCH}} - unofficial & generated by {{.GIT_AUTHOR}}'
      SOURCE_BRANCH: '{{.SOURCE_BRANCH | default .DEFAULT}}'

  # Lint & Format
  # ---------
  format:
    desc: format go project
    cmds:
      - gofmt -l -s -e -w .
      - golines -w -m 120 --shorten-comments .
      - >
        golangci-lint run
        --config={{.GOLANGCI_LINT_CFG}}
        --disable=godox
        --fix
        --issues-exit-code 0
        &> /dev/null
    vars:
      GOLANGCI_LINT_CFG: '{{.CONFIG_DIR}}/.golangci.yml'
    sources:
      - ./**/*.go
      - ./.golangci.yml
    preconditions:
      - sh: test $(which golines)
        msg: 'golines is missing'

  lint:
    desc: lint go project
    deps: [init]
    cmds:
      - go vet {{.PACKAGES}}
      - >
        golangci-lint run
        --config={{.GOLANGCI_LINT_CFG}}
        --disable=godox
        --sort-results
        --out-format
        code-climate:{{.LINT_REPORT}},junit-xml:{{.LINT_REPORT}}.xml,checkstyle:{{.LINT_REPORT}}.checkstyle,colored-line-number
        # &> /dev/null
    vars:
      GOLANGCI_LINT_CFG: '{{.CONFIG_DIR}}/.golangci.yml'
      LINT_REPORT: '{{.BUILD}}/{{.LINT_REPORT}}'
    sources:
      - ./**/*.go
      - ./.golangci.yml
    preconditions:
      - sh: '[[ -z $(gofmt -l -d -s -e .) ]]'
        msg: 'go files have not been formatted with gofmt'
      - sh: '[[ -z $(golines -m 120 --shorten-comments --dry-run .) ]]'
        msg: 'go files have not been formatted with golines'

  # Quality
  # ---------
  test:
    desc: test go project
    deps: [init]
    cmds:
      - go test {{.CLI_ARGS}} -parallel 6 {{.MODE}} {{.PACKAGES}} {{.TEST_FLAGS}}
    env:
      CC: '{{.CC}}'
      CXX: '{{.CXX}}'
      RUN_MONKEY_PATCH_TESTS: '{{.RUN_MONKEY_PATCH_TESTS}}'

  cover:
    desc: test go project with code coverage enabled
    deps:
      - init
      - cover-prereq
    cmds:
      - task: test
        vars:
          MODE: '-gcflags=-l -tags cover -covermode=set --coverprofile {{.COVER_REPORT}}.cov'
          RUN_MONKEY_PATCH_TESTS: 'true'
      - go tool cover -html={{.COVER_REPORT}}.cov -o {{.COVER_REPORT}}.html
    vars:
      COVER_REPORT: '{{.BUILD}}/{{.COVER_REPORT}}'
    sources:
      - ./**/*.go
    generates:
      - './{{.COVER_REPORT}}.cov'
      - './{{.COVER_REPORT}}.html'

  race:
    cmds:
      - task: test
        vars:
          MODE: '-race'

  msan:
    cmds:
      - task: test
        vars:
          MODE: '-msan'
          CC: clang
          CXX: clang++
    status:
      - test {{OS}} != "linux"

  # TODO: Add fuzzing target to the Taskfile for Go.
  fuzz:
    cmds:
      - task: test
        vars:
          MODE: '--not--implemented'

  genprofile:
    desc: generate profiles for go project
    deps: [init]
    cmds:
      - '{{.SCRIPTS_DIR}}/profilegen.sh {{.BENCH}} -d {{.BUILD}} -p {{.PROJECT}} {{.PACKAGES}}'
    vars:
      BENCH: '{{if eq .BENCH "true"}}-b{{else}}{{end}}'
    sources:
      - ./**/*.go
    generates:
      - '{{.BUILD}}/prof/**/*'

  profile:
    desc: view profiles for go project
    deps: [genprofile]
    cmds:
      - '{{.SCRIPTS_DIR}}/profileview.sh -f {{.FRACTION}} -i {{.IP}} -b {{.BUILD}} -p {{.PROJECT}} {{.PACKAGES}}'
    vars:
      FRACTION: '{{.FRACTION | default "0.0"}}'
      IP: '{{if eq OS "windows"}}localhost{{else}}0.0.0.0{{end}}'

  coverlines:
    deps: [cover]
    cmds:
      - |
        lines=$(uncover {{.COVER_REPORT}}.cov)

        if [ -z "$lines" ]; then
          echo "no uncovered lines"
          exit 0
        fi

        ignore_tag="//cover:ignore"
        while read -r line; do
          if [[ $line =~ ^[[:space:]] ]]; then
            if [[ $line != *"$ignore_tag"* ]]; then
              echo "uncovered line(s) detected"
              exit 1
            fi
          fi
        done <<< "$lines"
    vars:
      COVER_REPORT: '{{.BUILD}}/{{.COVER_REPORT}}'

  cover-prereq:
    cmds:
      - |
        for package in {{.PACKAGES}}; do
          prefix={{.PROJECT}}
          pkg=${package#$prefix}

          #skipping root package
          if [ -z "$pkg" ]; then
            continue
          fi

          file="./$pkg/*_test.go"
          if ! ls $file 1> /dev/null 2>&1; then
            echo "$package is missing a _test.go file, creating it!"
            if [ -z "$pkg" ]; then
              basename=$(basename $prefix)
            else
              basename=$(basename $pkg)
            fi
            test_file=./$pkg/${basename}_test.go
            echo "package ${basename}_test" >> $test_file
          fi
        done

  coverage:
    desc: calculate coverage value
    deps: [cover]
    cmds:
      - |
        want={{.COVERAGE}}
        coverage=$(go tool cover -func {{.COVER_REPORT}}.cov | grep total | awk '{print $3}')
        echo "Coverage is ${coverage}"
        got=${coverage%\%}; got=${got%.*}
        want=${want%\%}; want=${want%.*}
        echo "coverage: $got" > {{.BUILD}}/coverage-results
        if (( got < want )); then
          echo "Coverage (floored) ${got}% lower than expected ${want}%"
          exit 1
        fi
        echo "Coverage (floored) ${got}% passes expected ${want}%"
    vars:
      COVER_REPORT: '{{.BUILD}}/{{.COVER_REPORT}}'

  quality:
    desc: run all quality relevant tasks
    deps:
      - task: test
      - task: race
      - task: msan
      - task: cover
    cmds:
      # TODO: fix sed for Windows (not escaping properly?)
      - gotestsum --junitfile {{.TEST_REPORT}}.xml --format testname --packages {{.PACKAGES}}
      - |
        gocover-cobertura < {{.COVER_REPORT}}.cov > {{.COVER_REPORT}}.xml
        sed -i 's;filename="{{.PROJECT}}/;filename=";g' {{.COVER_REPORT}}.xml || exit 0
      - task: coverage
    vars:
      TEST_REPORT: '{{.BUILD}}/{{.TEST_REPORT}}'
      COVER_REPORT: '{{.BUILD}}/{{.COVER_REPORT}}'
    preconditions:
      - sh: test $(which gotestsum)
        msg: 'gotestsum is missing'
      - sh: test $(which gocover-cobertura)
        msg: 'gocover-cobertura is missing'
    status:
      - test {{OS}} != "linux"

  # Documentation
  # ---------
  doc:
    desc: run godoc on go project
    cmds:
      - echo "publishing on :8888"
      - godoc -notes 'BUG|TODO' -http=:8888 &
      - sleep 2
      - echo "press [enter] to quit" && read -r

    preconditions:
      - sh: test $(which godoc)
        msg: 'godoc is missing'

  graph:
    desc: output graph file showing dependencies
    deps: [init]
    cmds:
      - goda graph -short ./... | dot -T jpg -o {{.BUILD}}/dependencies.jpg

  # ---------
  all:
    cmds:
      - task: mod
      - task: format
      - task: lint
      - task: build
      - task: quality
      - task: profile
      - task: graph
